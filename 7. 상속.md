# 상속 개념

- 상속을 통해 부모 클래스의 필드나 메서드를 자식 클래스에 물려줄 수 있다.
- 이미 개발된 클래스를 상속해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다.
- 부모 클래스를 수정함으로써 자식 클래스들도 수정된 클래스와 메서드를 사용할 수 있기 때문에 수정을 최소화시킬 수 있다.
- 상속 대상에서 제외되는 경우
  - 부모 클래스에서 `private`이 붙은 필드나 메서드
  - 부모 클래스와 자식 클래스가 다른 패키지에 존재할 경우, `default` 접근 제한을 갖는 필드나 메서드

# 클래스 상속
- 상속은 자식 클래스에서 `extends` 뒤에 부모 클래스를 작성해주면 된다.
- 자바는 다중 상속을 허용하지 않는다. `extends` 뒤에는 하나의 부모 클래스만 올 수 있다.

```java
public class ChildClass extends ParentClass {
}
```

# 부모 생성자 호출
- 자식 객체를 생성하면 내부적으로는 부모 객체가 먼저 생성되고 그 다음에 자식 객체가 생성된다.
- 부모 객체는 자식 객체 생성자에서 생성된다. 자식 클래스의 생성자가 명시적으로 선언되지 않았다면 컴파일러가 자동으로 다음과 같이 기본 생성자를 만들어준다. 첫 줄에서 `super()`로 부모의 기본 생성자를 호출한다.

```java
public ChildClass() {
    super();
}
```

- 자식 클래스에서 직접 생성자를 선언하고 명시적으로 부모 생성자를 호출해줘도 된다.
```java
public ChildClass(String field1, String field2) {
    super(field1, field2);
}
```
- 부모 생성자 호출을 생략하면 자동으로 `super()`가 추가되기 때문에 부모의 기본 생성자가 존재해야 한다.
- 만약 부모 클래스에 기본 생성자가 없고, 매개 변수가 있는 생성자만 있다면 자식 클래스에서 반드시 매개 변수가 있는 생성자를 명시적으로 호출해줘야 한다. 그리고 반드시 첫 줄에서 호출해줘야 한다.


# 메소드 재정의

## 메소드 재정의 (@Override)
- 부모 클래스에서 상속받은 메서드를 자식 메서드에서 재정의하는 것이다.
- 메서드가 오버라이딩되면 자식 객체에서 메서드를 호출시 오버라이딩된 자식 메서드가 호출된다.
- 오버라이딩시 주의할 점
  - 부모의 메서드와 동일한 시그너처(리턴 타입, 메서드명, 매개변수 리스트)를 가져야 한다.
  - 접근 제한을 더 강하게 할 수 없다. (반대는 가능)
    - 부모 메서드가 `public`일 때, 자식 메서드에서 `default`나 `private`으로 수정은 불가능
    - 부모 메서드가 `default`일 때, 자식 메서드에서 `public`으로는 수정 가능
  - 새로운 예외(Exception)를 던질수는 없다.
- 메서드에 `@Override` 애노테이션을 붙여서 오버라이딩하면 된다.

## 부모 메소드 호출 (super)
- 자식 클래스 내부에서 부모 클래스의 메서드를 호출해야 하는 경우, `super`를 통해 호출할 수 있다.
- `super`는 부모 객체를 참조하고 있으므로 부모 메서드에 직접 접근할 수 있다.
```java
super.method1();
```


# final 클래스와 final 메소드

- 클래스와 메소드 선언에 `final`이 붙으면 상속과 관련이 있다.

## final 클래스
- 클래스에 `final`이 붙으면 해당 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다.
- 대표적인 예로는 `String` 클래스가 있다.
```java
public final class String {}
```

## final 메소드
- 메서드에 `final`이 붙으면 해당 메서드는 최종적인 메서드이므로 오버라이딩할 수 없는 메서드가 된다.
```java
public final void method1() {}
```

# protected 접근 제한자

- 접근 제한자는 `public`, `protected`, `default`, `private` 이 4가지가 있는데, 이 중 `protected`는 상속과 관련이 있다.
- `protected`는 필드, 생성자, 메서드에 적용할 수 있다.
- 같은 패키지에서는 모두 접근이 가능하지만 다른 패키지에서는 자식 클래스만 접근을 허용한다.

# 타입 변환과 다형성

- 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있다.
- 자바에서는 다형성을 위해 부모 클래스로 타입 변환을 허용한다.

## 자동 타입 변환 (Promotion)
- 자동 타입 변환은 프로그램 실행 도중에 자동으로 타입 변환이 되는 것을 말한다.
- 자식 클래스는 부모 클래스로 타입 변환이 가능하다.
- 바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이면 자동 타입 변환이 가능하다.
- 부모 타입으로 변환이 된 후에는 부모 클래스에 있는 필드나 메서드에만 접근이 가능하다. 하지만 오버라이딩된 메서드를 호출하는 경우에는 자식 클래스의 오버라이딩된 메서드가 호출된다.
```java
Cat cat = new Cat();
Animal animal = cat;    // 자동 타입 변환
```

## 필드의 다형성
- 필드의 타입을 변경하지 않고도 실행 도중에 필드에 저장되는 객체를 바꿀 수 있다.

## 하나의 배열로 객체 관리
- 부모 타입 배열에 자식 객체들을 넣어서 깔끔하게 관리할 수 있다. 배열에 넣으면 인덱스를 이용할 수 있고 반복문 등에서 활용하기 좋다.

## 매개 변수의 다형성
- 메서드에서 매개 변수로 부모 타입을 선언해주면, 자식 타입 객체를 매개값으로 받을 수 있다.

## 강제 타입 변환 (Casting)
- 강제 타입 변환은 부모 타입을 자식 타입으로 변환하는 것을 말한다.
- 자식 타입이 부모 타입으로 자동 변환된 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.
- 자식 타입을 부모 타입으로 변환하면 부모 타입의 필드와 메서드만 사용이 가능하기 때문에 자식 타입의 필드와 메서드를 사용하려면 강제 타입 변환을 해서 사용하면 된다.
```java
Parent parent = new Child();
parent.childMethod();    // 불가능

Child child = (Child) parent;   // 강제 타입 변환
child.childMethod();     // 가능
```

## 객체 타입 확인 (instanceof)
- 강제 타입 변환은 자식 타입이 부모 타입으로 변환된 상태에서만 사용이 가능하다. 따라서 객체가 부모 클래스의 객체인지 자식 클래스의 객체인지를 확인해야 한다.
- `instanceof`를 사용하면 객체가 특정 클래스의 인스턴스인지 여부를 알 수 있다.
```java
if (parent instanceof Child) {
    Child child = (Child) parent;
}
```

# 추상 클래스

## 추상 클래스 개념

- 실체 클래스 : 객체를 직접 생성할 수 있는 클래스
- 추상 클래스 : 실체 클래스들의 공통적인 특성을 추출해서 선언한 클래스
- 추상 클래스와 실체 클래스는 상속의 관계를 가지고 있다. 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있다.
- 추상 클래스는 객체를 직접 생성해서 사용할 수 없다. `new`를 사용해서 인스턴스를 생성하지 못한다.
- 추상 클래스는 실체 클래스를 만들기 위한 부모 클래스로만 사용된다. 즉, `extends` 뒤에만 올 수 있다.

## 추상 클래스의 용도

- 공통 필드와 메소드 이름을 통일

  - 실체 클래스를 여러 사람이 설계할 경우 클래스마다 다른 이름을 가지지 않도록 공통적인 필드나 메소드의 이름을 통일하기 위해 사용할 수 있다.

- 실체 클래스 작성 시간 절약
  - 공통적인 필드와 메소드는 추상 클래스에 정의해놓고, 다른 점만 실체 클래스에 정의하게 되면 실체 클래스를 작성할 때 시간을 절약할 수 있다.

## 추상 클래스 선언

- 클래스 선언에 `abstract`를 붙이면 된다.
- 자식 객체가 생성될 때 `super()`를 호출해서 추상 클래스 객체를 생성하므로 생성자가 반드시 있어야 한다.

**추상 클래스**

```java
public abstract class Phone {

    public String owner;

    public Phone(String owner) {
        this.owner = owner;
    }

    public void turnOn() {
        System.out.println("전원을 켭니다");
    }

    public void turnOff() {
        System.out.println("전원을 끕니다");
    }
}
```

**실체 클래스**

```java
public class SmartPhone extends Phone {

    public SmartPhone(String owner) {
        super(owner);
    }

    public void internetSearch() {
        System.out.println("인터넷 검색을 합니다.");
    }
}
```

## 추상 메소드와 오버라이딩

- 추상 클래스에서 메소드의 선언만 통일화하고, 실행 내용은 실체마다 다르게 해야할 경우 추상 메소드를 사용하면 된다.
- 추상 메소드는 추상 클래스에서만 선언할 수 있다.
- 메소드의 선언부만 있고 실행 내용인 중괄호 {}가 없는 메소드이다.
- 자식 클래스는 추상 메소드를 반드시 오버라이딩해야 한다.

```java
public abstract class Animal {
    public abstract void sound();   // 추상 메소드
}
```
